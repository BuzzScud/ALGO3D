#ifndef CLLM_SPACE88D_OPS_H
#define CLLM_SPACE88D_OPS_H

#include "ai/space_88d.h"
#include "../../algorithms/include/hierarchical_threading.h"

/**
 * @file cllm_space88d_ops.h
 * @brief High-level operations for Space88D in CLLM context
 * 
 * This module provides layer-based operations specifically designed
 * for CLLM's hierarchical threading architecture.
 */

#ifdef __cplusplus
extern "C" {
#endif

// ============================================================================
// LAYER SELECTION & MANAGEMENT
// ============================================================================

/**
 * @brief Select optimal layer for a value based on magnitude
 * 
 * Automatically chooses the appropriate layer (octave) based on the
 * magnitude of the value. Larger values use higher layers.
 * 
 * @param sphere The sphere whose space to update
 * @param value The value to analyze
 * @return The selected layer (0-7), or -1 on error
 */
int cllm_space88d_select_layer(CLLMLatticeHierarchy* sphere, 
                               const CrystallineAbacus* value);

/**
 * @brief Get the currently active layer for a sphere
 * 
 * @param sphere The sphere to query
 * @return The active layer (0-7), or -1 on error
 */
int cllm_space88d_get_active_layer(const CLLMLatticeHierarchy* sphere);

/**
 * @brief Set the active layer for a sphere
 * 
 * @param sphere The sphere to update
 * @param layer The layer to activate (0-7)
 * @return 0 on success, -1 on error
 */
int cllm_space88d_set_active_layer(CLLMLatticeHierarchy* sphere, uint8_t layer);

// ============================================================================
// LAYER-BASED ARITHMETIC
// ============================================================================

/**
 * @brief Add value to specific layer and dimension
 * 
 * @param sphere The sphere whose space to modify
 * @param layer Layer index (0-7)
 * @param dimension Dimension index (0-10)
 * @param value Value to add
 * @return 0 on success, -1 on error
 */
int cllm_space88d_add_to_position(CLLMLatticeHierarchy* sphere,
                                  uint8_t layer, uint8_t dimension,
                                  const CrystallineAbacus* value);

/**
 * @brief Multiply position by value
 * 
 * @param sphere The sphere whose space to modify
 * @param layer Layer index (0-7)
 * @param dimension Dimension index (0-10)
 * @param value Value to multiply by
 * @return 0 on success, -1 on error
 */
int cllm_space88d_multiply_position(CLLMLatticeHierarchy* sphere,
                                    uint8_t layer, uint8_t dimension,
                                    const CrystallineAbacus* value);

/**
 * @brief Scale entire layer by a factor
 * 
 * @param sphere The sphere whose space to modify
 * @param layer Layer to scale (0-7)
 * @param scale_factor Factor to scale by
 * @return 0 on success, -1 on error
 */
int cllm_space88d_scale_layer(CLLMLatticeHierarchy* sphere,
                              uint8_t layer,
                              const CrystallineAbacus* scale_factor);

// ============================================================================
// CROSS-LAYER OPERATIONS
// ============================================================================

/**
 * @brief Copy values from one layer to another
 * 
 * @param sphere The sphere whose space to modify
 * @param src_layer Source layer (0-7)
 * @param dst_layer Destination layer (0-7)
 * @return 0 on success, -1 on error
 */
int cllm_space88d_copy_layer(CLLMLatticeHierarchy* sphere,
                             uint8_t src_layer, uint8_t dst_layer);

/**
 * @brief Add two layers element-wise, store in destination
 * 
 * @param sphere The sphere whose space to modify
 * @param layer1 First layer (0-7)
 * @param layer2 Second layer (0-7)
 * @param dst_layer Destination layer (0-7)
 * @return 0 on success, -1 on error
 */
int cllm_space88d_add_layers(CLLMLatticeHierarchy* sphere,
                             uint8_t layer1, uint8_t layer2,
                             uint8_t dst_layer);

/**
 * @brief Compute dot product of two layers
 * 
 * Computes the sum of element-wise products across all 11 dimensions.
 * 
 * @param sphere The sphere whose space to query
 * @param layer1 First layer (0-7)
 * @param layer2 Second layer (0-7)
 * @return Dot product result, or NULL on error (caller must free)
 */
CrystallineAbacus* cllm_space88d_layer_dot_product(
    const CLLMLatticeHierarchy* sphere,
    uint8_t layer1, uint8_t layer2);

/**
 * @brief Transfer value between layers with magnitude scaling
 * 
 * Moves a value from one layer to another, automatically applying
 * the appropriate magnitude scaling (factor of 12 per layer).
 * 
 * @param sphere The sphere whose space to modify
 * @param src_layer Source layer (0-7)
 * @param dst_layer Destination layer (0-7)
 * @param dimension Dimension to transfer (0-10)
 * @return 0 on success, -1 on error
 */
int cllm_space88d_transfer_between_layers(CLLMLatticeHierarchy* sphere,
                                          uint8_t src_layer,
                                          uint8_t dst_layer,
                                          uint8_t dimension);

// ============================================================================
// LAYER INFORMATION
// ============================================================================

/**
 * @brief Get magnitude scale for a layer
 * 
 * Each layer represents a different magnitude range (octave).
 * Layer 0: 10^0, Layer 1: 10^3, Layer 2: 10^6, etc.
 * 
 * @param layer Layer index (0-7)
 * @return Magnitude scale, or 0.0 on error
 */
double cllm_space88d_get_layer_scale(uint8_t layer);

/**
 * @brief Get Platonic solid type for a layer
 * 
 * Each layer uses a specific Platonic solid as its coordinate frame.
 * 
 * @param layer Layer index (0-7)
 * @return Platonic solid type
 */
PlatonicSolidType cllm_space88d_get_layer_solid(uint8_t layer);

/**
 * @brief Get frequency for a layer
 * 
 * Each layer has an associated harmonic frequency.
 * 
 * @param layer Layer index (0-7)
 * @return Frequency in Hz, or 0.0 on error
 */
double cllm_space88d_get_layer_frequency(uint8_t layer);

// ============================================================================
// DIMENSION OPERATIONS
// ============================================================================

/**
 * @brief Get value at specific position
 * 
 * @param sphere The sphere to query
 * @param layer Layer index (0-7)
 * @param dimension Dimension index (0-10)
 * @return Pointer to value (do not free), or NULL on error
 */
const CrystallineAbacus* cllm_space88d_get_value(
    const CLLMLatticeHierarchy* sphere,
    uint8_t layer, uint8_t dimension);

/**
 * @brief Set value at specific position
 * 
 * @param sphere The sphere to modify
 * @param layer Layer index (0-7)
 * @param dimension Dimension index (0-10)
 * @param value Value to set (will be copied)
 * @return 0 on success, -1 on error
 */
int cllm_space88d_set_value(CLLMLatticeHierarchy* sphere,
                            uint8_t layer, uint8_t dimension,
                            const CrystallineAbacus* value);

/**
 * @brief Zero out a specific dimension across all layers
 * 
 * @param sphere The sphere to modify
 * @param dimension Dimension to zero (0-10)
 * @return 0 on success, -1 on error
 */
int cllm_space88d_zero_dimension(CLLMLatticeHierarchy* sphere,
                                 uint8_t dimension);

/**
 * @brief Zero out a specific layer
 * 
 * @param sphere The sphere to modify
 * @param layer Layer to zero (0-7)
 * @return 0 on success, -1 on error
 */
int cllm_space88d_zero_layer(CLLMLatticeHierarchy* sphere, uint8_t layer);

// ============================================================================
// DEBUGGING & DIAGNOSTICS
// ============================================================================

/**
 * @brief Print layer information
 * 
 * @param sphere The sphere to print
 * @param layer Layer to print (0-7)
 */
void cllm_space88d_print_layer(const CLLMLatticeHierarchy* sphere,
                               uint8_t layer);

/**
 * @brief Print all layers
 * 
 * @param sphere The sphere to print
 */
void cllm_space88d_print_all(const CLLMLatticeHierarchy* sphere);

/**
 * @brief Get statistics for a layer
 * 
 * @param sphere The sphere to analyze
 * @param layer Layer to analyze (0-7)
 * @param min Output: minimum value (caller must free)
 * @param max Output: maximum value (caller must free)
 * @param sum Output: sum of all values (caller must free)
 * @return 0 on success, -1 on error
 */
int cllm_space88d_layer_stats(const CLLMLatticeHierarchy* sphere,
                              uint8_t layer,
                              CrystallineAbacus** min,
                              CrystallineAbacus** max,
                              CrystallineAbacus** sum);

#ifdef __cplusplus
}
#endif

#endif // CLLM_SPACE88D_OPS_H